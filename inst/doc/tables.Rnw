\documentclass[12pt]{article}
\usepackage{Sweave}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{longtable}

\usepackage[authoryear,round,comma]{natbib}
\bibliographystyle{plainnat}

%\VignetteIndexEntry{About the tables package}

\makeatletter
\newcommand\code{\bgroup\@makeother\_\@makeother\~\@makeother\$\@codex}
\def\@codex#1{{\normalfont\ttfamily\hyphenchar\font=-1 #1}\egroup}
\makeatother

\newcommand{\pkg}[1]{{\fontseries{b}\selectfont #1}}

% The next line is needed for inverse search...
\SweaveOpts{concordance=TRUE, keep.source=TRUE}
<<echo=false>>=
options(width=60)
@

\title{The \pkg{tables} Package\footnote{This 
vignette  was built using \pkg{tables} version \Sexpr{packageDescription("tables")$Version}}.}%$

\author{Duncan Murdoch}

\begin{document}

\maketitle

\tableofcontents

\section{Introduction}

This is a short introduction to the \pkg{tables} package.  Inspired by my 20 year old memories
of SAS PROC TABULATE, I decided to write a simple utility to create nice looking tables in Sweave 
documents.  For example, we might display summaries of some of Fisher's iris data using the
code
<<echo=FALSE>>=
library(tables)
@
<<iris>>=
tabular( (Species + 1) ~ (n=1) + Format(digits=2)*
         (Sepal.Length + Sepal.Width)*(mean + sd), data=iris )
@
You can also pass the output through the \code{Hmisc::latex()} function \citep{Hmisc,HmiscLatex}
to produce \LaTeX\ output,
which when processed by \code{pdflatex} will produce the following table:
\begin{center}
<<echo=FALSE, results=tex>>=
latex(
<<iris>>
)
@
\end{center}

If you prefer the style of table that the \LaTeX\ \pkg{booktabs} package \citep{booktabs}
produces, you can choose
that style instead.  I mostly like it, so I have used
<<eval=FALSE>>=
booktabs()
@
for the rest of this document.  This gives
\begin{center}
<<echo=FALSE, results=hide>>=
saved.options <- table_options()
booktabs()
@
<<irisbook, echo=FALSE, results=tex>>=
latex(
<<iris>>
)
@


\end{center}

The idea of a table in the \pkg{tables} package is a rectangular array of values, with
each row and column labelled, and possibly with groups of rows and groups of columns
also labelled.  These arrays are specified by ``table formulas''.

Table formulas are R formula objects, with the  rows of the table
described before the tilde (\code{"~"}), and the columns after.   Each of
those is an expression containing \code{"*"}, \code{"+"}, \code{"="}, as
well as functions, function calls and variables, and parentheses for
grouping.  There are also various directives included in the formula,
entered as ``pseudo-functions'', i.e. expressions that look like function
calls but which are interpreted by the \code{tabular()} function.

For example, in the formula 
\begin{Schunk}
\begin{Sinput}
(Species + 1) ~ (n=1) + Format(digits=2)*
         (Sepal.Length + Sepal.Width)*(mean + sd)
\end{Sinput}
\end{Schunk}
the rows are given by \verb!(Species + 1)!.  The summation here is interpreted as concatenation, i.e.
this says rows for \code{Species} should be followed by rows for \code{1}.

In the \code{iris} dataframe, \code{Species} is a factor, so the rows for it correspond to its levels.

The \code{1} is a place-holder, which in this context will mean ``all groups''.

The columns in the table are defined by
\begin{Schunk}
\begin{Sinput}
(n=1) + Format(digits=2)*(Sepal.Length + Sepal.Width)*(mean + sd)
\end{Sinput}
\end{Schunk}
Again, summation corresponds to concatenation, so the first column corresponds to \code{(n=1)}.
This is another use of the placeholder, but this time it is labelled as \code{n}.  
Since we haven't specified any other statistic to use, the first
column contains the counts of values in the dataframe in each category.

The second term in the column formula is a product of three factors.
The first, \code{Format(digits=2)}, is a pseudo-function to set the format for all of the entries to
come.  (For more on formats, see section \ref{sec:formats} below.)  The second factor, \code{(Sepal.Length
+ Sepal.Width)}, is a concatenation of two variables.  Both of these
variables are numeric vectors in \code{iris}, and they each become the
variable to be analyzed, in turn.  The last factor, \code{(mean + sd)}
names two R functions.  These are assumed to be functions that
operate on a vector and produce a single value, as \code{mean} and
\code{sd} do.  The values in the table will be the results of applying
those functions to the two different variables and the subsets of the
dataset.

\section{Reference}

For the examples below we use the following definitions:
<<>>=
set.seed(100)
X <- rnorm(10)
X
A <- sample(letters[1:2], 10, rep=TRUE)
A
F <- factor(A)
F
@

\subsection{Function syntax}

\subsubsection{\code{tabular()}}

\begin{Schunk}
\begin{Sinput}
tabular(table, ...)
tabular.default(table, ...)
tabular.formula(table, data=parent.frame(), n, suppressLabels=0, ...) 
\end{Sinput}
\end{Schunk}

The \code{tabular} function is a generic function.  The default method
uses \code{as.formula()} to try to convert the \code{table} argument
to a formula, then passes it and all the other arguments to 
\code{tabular.formula()} method, which does most of the work.  That
method has 4 arguments plus \code{...}, but usually only the first two
are used, and a warning is issued if anything is passed in the
\code{...} arguments.

\begin{description}
\item[table] The \code{table} argument is the table formula, described in detail below.

\item[data] The \code{data} argument is a dataframe or environment in which to look for 
the data referenced by the table.  

\item[n]  The \code{tabular} function needs to know the length of vectors on which it operates, because 
some formulas (e.g. \code{1 ~ 1}) contain no data.  Normally \code{n} is taken as the
number of rows in \code{data}, or the length of the first referenced object in the formula,
but sometimes the user will need to specify it.  Once specified, it can't be modified:
all data in the table should be the same length.

\item[suppressLabels] By default, \code{tabular} adds a row or column label for each term, but
this does sometimes make the table messy.  Setting \code{suppressLabels} to a positive
integer will cause that many labels to be suppressed at the start of each term.  The
pseudo-function \code{Heading()} can achieve the same effect, one term at a time.
\end{description}

The value returned is a list-mode matrix corresponding to the entries in the table, 
with a number of attributes to help with formatting.  See the \code{?tabular} help page
for more details.

\subsubsection{\code{format(), print(), latex()}}
\label{sec:formatsyntax}

\begin{Schunk}
\begin{Sinput}
format(x, digits=4, justification="n", ...) 
print(x, ...)
latex(x, file="", options=NULL,  ...)
\end{Sinput}
\end{Schunk}


The \code{tables} package provides methods for the \code{format()}, \code{print()} 
and \code{Hmisc::latex()} generics.
The arguments are:
\begin{description}
\item[x] The tabular object returned from \code{tabular()}.
\item[digits] The default number of digits to use when formatting.
\item[justification] The default text justification to use when printing.  For text display, the
recognized values are \code{"n", "l", "c", "r"}, standing for none, left, center and right
justification respectively.  For \LaTeX\ the justification is 
specified via the \code{table_options()} function. 
\item[file] The default method for the \code{Hmisc::latex()} generic writes the \LaTeX\ code
to a file; \code{latex.tabular()} can optionally do the same, but it defaults to writing to screen,
for use in Sweave documents like this one.
\item[options] A list of options to pass to \code{table_options()}.  These
will be set only for the duration of the call to \code{latex()}.
\end{description}

\subsubsection{\code{as.matrix(), write.csv.tabular(), write.table.tabular()}}

\begin{Schunk}
\begin{Sinput}
as.matrix(x, format = TRUE, 
    rowLabels = TRUE, colLabels = TRUE, justification = "n", ...)
write.csv.tabular(x, file = "", justification = "n", row.names=FALSE, 
    write.options=list(), ...)
 write.table.tabular(x, file="", 
    justification = "n", row.names=FALSE, col.names=FALSE,
    write.options=list(), ...)   
\end{Sinput}
\end{Schunk}

These functions export tables for further computations.  The arguments are:
\begin{description}
\item[x] The tabular object.
\item[format] Whether to format the entries.  See the help page for alternatives.
\item[rowLabels, colLabels] If formatting, whether to include the labels or not.
\item[justification] The default text justification to use when formatting.
\item[file] Where to write the output.
\item[row.names,col.names, write.options] Additional parameters to pass
to \code{write.csv()} or \code{write.table()}.
\end{description}


\subsubsection{\code{table\textunderscore options(), booktabs()}}
\label{sec:booktabs}

The \code{table\textunderscore options()} function sets a number of formatting defaults for the \code{latex()}
method:
\begin{description}
\item[justification] This is the default justification for data columns and their headers.
Any justification string will be accepted; it should be
one that the \LaTeX\ \verb+\tabular+ environment (or substitute) accepts.
\item[rowlabeljustification] This is the default justification for row labels.
\item[tabular] The environment to use in \LaTeX.  Alternatives to \code{"tabular"} such as
\code{"longtable"} can be used here.  Those often also need 
modifications within the table; the \code{Literal()} (section \ref{sec:Literal}) function may be
helpful.
\item[toprule, midrule, bottomrule] The \LaTeX\ macros to draw the top, middle and bottom lines
in the table.  By default these are all \verb!"\\hline"!.
\item[titlerule] An optional \LaTeX\ macro to draw a line under multicolumn titles.
\item[doBegin, doHeader, doBody, doFooter, doEnd]
These logical values control the inclusion of specific parts of
the output table.
\end{description}
The defaults are
<<echo=FALSE>>=
saved.options
@

If you are using the \LaTeX\ \pkg{booktabs} package, the \code{booktabs()} function will
set different options.  Currently those are:
<<echo=FALSE>>=
table_options()[c("toprule", "midrule", "bottomrule", "titlerule")]
@

The earlier table of iris data was produced using
<<eval=FALSE>>=
<<irisbook>>
@
\begin{center}
<<results=tex,echo=FALSE>>=
<<irisbook>>
@
\end{center}


We can use the \code{doXXXX} options to insert raw \LaTeX\ into a table:
<<split, eval=FALSE>>=
latex(tabular(Species ~ (n=1) + Format(digits=2)*
         (Sepal.Length + Sepal.Width)*(mean + sd), data=iris),
      options=list(doFooter=FALSE, doEnd=FALSE))
cat("\\ \\\\ \\multicolumn{6}{l}{
\\textit{Overall, we see the following: }} \\\\
\\ \\\\")
latex(tabular(1 ~ (n=1) + Format(digits=2)*
         (Sepal.Length + Sepal.Width)*(mean + sd), data=iris),
      options=list(doBegin=FALSE, doHeader=FALSE))
@
\begin{center}
<<results=tex, echo=FALSE>>=
<<split>>
@
\end{center}

\subsubsection{\code{latexNumeric()}}
\label{sec:latexNumeric}

\begin{Schunk}
\begin{Sinput}
latexNumeric(chars, minus = TRUE, leftpad = TRUE, rightpad=TRUE, 
                        mathmode = TRUE)
\end{Sinput}
\end{Schunk}

The \code{latexNumeric()} function converts character representations of numbers
into a format suitable for display in \LaTeX\ documents.  There are two goals:
\begin{itemize}
\item If \code{chars} is a vector with constant width, then the output will also be constant width.
This means the default centering used in \code{tabular()} will not misalign decimal points (if
they were aligned in \code{chars}).
\item Minus signs will be displayed with the proper symbol rather than a hyphen.
\end{itemize}

The arguments are:
\begin{description}
\item[chars]
A character vector of formatted numeric values.
\item[minus]
Whether to pad positive cases with spacing of the same width as a minus sign.  If \code{TRUE}
and some entries are negative, then all positive entries will be padded.
\item[leftpad, rightpad]
Whether to pad cases that have leading or trailing blanks with spacing matching a digit width per space.
If \code{leftpad=TRUE}, leading blanks will be converted to spaces the same width as a digit 0.  (If
\code{minus=TRUE}, one leading blank may have been consumed in the sign padding.)
The \code{rightpad} argument handles trailing blanks similarly.

\item[mathmode]
Whether to wrap the result in dollar signs, so \LaTeX\ will render minus signs properly.
\end{description}

\subsection{Operators}


\subsubsection{$e_1 + e_2$}

Summing two expressions indicates that they
should be displayed in sequence.  For rows, this means $e_1$ will be
displayed just above $e_2$; for columns, $e_1$ will be just to the left of
$e_2$.

Example:
\begin{center}
<<results=tex>>=
latex( tabular(F + 1 ~ 1) )
@
\end{center}

\subsubsection{$e_1 * e_2$}

Multiplying two expressions means that each
element of $e_1$ will be applied to each element of $e_2$.  If $e_1$ is 
a factor, then $e_2$ will be displayed for each element of it.   NB:  $*$ has
higher precedence than $+$ and evaluation proceeds from left to right.
The expression $(e_1 + e_2)*(e_3 + e_4)$
is equivalent to $e_1*e_3 + e_1*e_4 + e_2*e_3 + e_2*e_4$.

Example:
\begin{center}
<<results=tex>>=
latex( tabular( X*F*(mean + sd) ~ 1 ) )
@
\end{center}

\subsubsection{$e_1 \sim e_2$}

The tilde separates row specifications from
column specifications, but otherwise acts the same as $*$, i.e.
each row value applies to each column.

Example:
\begin{center}
<<results=tex>>=
latex( tabular( X*F ~ mean + sd ) )
@
\end{center}

\subsubsection{$e_1 = e_2$}

The operator $=$ is used to set the name of
$e_2$ to a displayed version of $e_1$.  It is an abbreviation for
\code{Heading(}$e_1$\code{)*}$e_2$.  NB:  because $=$ has lower 
operator precedence than any other operator, we usually put
parentheses around these expressions, i.e. $(e_1 = e_2)$.

Example: \code{F} is renamed to ``Newname''.
\begin{center}
<<results=tex>>=
latex( tabular( X*(Newname=F) ~ mean + sd ) )
@
\end{center}

\subsection{Terms in Formulas}

R parses table formulas into sums, products, and bindings separated by the tilde formula operator.  What comes between the
operators are other expressions.  Other than the pseudo-functions described in section \ref{sec:pseudo}, these are evaluated
and the actions depend on the type of the resulting value.  

\subsubsection{Closures or other functions}

If the expression evaluates to a function (e.g. it is the name of a function), then that function
becomes the summary statistic to be displayed.  The summary statistic should take a vector of values as input, and return a single 
value (either numeric, character, or some other simple printable value).  If no summary function is specified, the default is
\code{length}, to count the length of the vector being passed.  

Note that only one summary function can be specified for any cell in the table or an error will be
reported.

Example: \code{mean} and \code{sd} are specified functions; \code{n} is the renamed default statistic.
\begin{center}
<<results=tex>>=
latex( tabular( (F+1) ~ (n=1) + X*(mean + sd) ) )
@
\end{center}

\subsubsection{Factors}

If the expression evaluates to a factor, the dataset is broken up into subgroups according to the levels of the factor.
Most of the examples above have shown this for the factor \code{F}, but this can also be used to display complete datasets:

Example:  creating a factor to show all data.  Use the \code{identity} function to
display the values in each cell.
\begin{center}
<<results=tex>>=
latex( tabular( (i = factor(seq_along(X)))  ~ 
       Heading()*identity*(X+A + 
              (F = as.character(F) ) ) ) ) 
@
\end{center} 

\subsubsection{Logical vectors}

If the expression evaluates to a logical vector, it is used to subset the data.

Example:  creating subsets on the fly. 
\begin{center}
<<results=tex>>=
latex( tabular( (X > 0) + (X < 0)  + 1
    ~ ((n = 1) + X*(mean + sd)) ) )
@
\end{center} 

\subsubsection{Language Expressions}

If the expression evaluates to a language object, e.g. the result of \code{quote()} or \code{substitute()}, 
then it will be replaced in the table formula by its result.  This allows complicated table formulas
to be saved and re-used.  For examples, see section \ref{sec:tableformulas}.


\subsubsection{Other vectors}

If the expression evaluates to something other than the above, then it
is assumed to be a vector of values to be summarized in the table.  If
you would like to summarize a factor or logical vector, wrap it in
\code{I()} to prevent special handling.

Note that the following must all be true, or an error will be reported:
\begin{itemize}
\item only one value vector can be specified for any cell in the
table, 
\item all value vectors must be the same length, 
\item \code{is.atomic()}
must evaluate to \code{TRUE} for the vector.
\end{itemize}

Example:  treating a logical vector as values.
\begin{center}
<<results=tex>>=
latex( tabular( I(X > 0) + I(X < 0)  
    ~ ((n=1) + mean + sd) ) )
@
\end{center} 

\subsection{``Pseudo-functions''}
\label{sec:pseudo}

Several directives to \pkg{tables} may be embedded in the table formula.  This is done using ``pseudo-functions''.  Syntactically
they look like function calls, but reserved names are used.  In each case, their action applies to later factors in the term in which they appear.
For example,
\begin{center}
 \code{X*Justify(r)*(Y + Format(digits=2)*Z) + A}
\end{center} 
will apply the \code{Justify(r)} directive to both \code{Y} and \code{Z}, but
the \code{Format(digits=2)} directive will only apply to \code{Z}, and neither will apply to \code{A}.

\subsubsection{\code{Format()}}
\label{sec:formats}

By default \pkg{tables} formats each column
using the standard \code{format()} function, with arguments taken from the
\code{format.tabular()} call (see section \ref{sec:formatsyntax}).

The \code{Format()} pseudo-function does two
things:  it changes the formatting, and it specifies that all values it applies to will be formatted together.   The ``call'' to \code{Format} looks like a call to \code{format}, but without 
specifying the argument \code{x}.  When \code{tabular()} formats the output it will construct
\code{x} from the entries in the table governed by the \code{Format()} specification.

Example:  The mean and standard deviation are both governed by the same format, so
they are displayed with the same number of decimal places, chosen so that the smallest
values (the means) show two significant digits.
\begin{center}
<<results=tex>>=
latex( tabular( (F+1) ~ (n=1) 
           + Format(digits=2)*X*(mean + sd) ) )
@
\end{center}

For customized formatting, an alternate syntax is to pass a function call to \code{Format()}, rather
than a list of arguments.  The function should accept an argument named \code{x} (but as with the
regular formatting, \code{x} should not be included in the formula), to contain the data.  It should return a character vector
of the same length as x.

Example:  Use a custom function and \code{sprintf()} to display a standard error in parentheses.
\begin{center}
<<results=tex>>=
stderr <- function(x) sd(x)/sqrt(length(x))
fmt <- function(x, digits, ...) {
  s <- format(x, digits=digits, ...)
  is_stderr <- (1:length(s)) > length(s) %/% 2
  s[is_stderr] <- sprintf("$(%s)$", s[is_stderr])
  s[!is_stderr] <- latexNumeric(s[!is_stderr])
  s
}
latex( tabular( Format(fmt(digits=1))*(F+1) ~ X*(mean + stderr) ) )
@
\end{center}


\subsubsection{\code{.Format()}}

The pseudo-function \code{.Format()} is mainly intended for internal use. It takes a single integer argument, saying that data governed by this call uses the same formatting as the format specification
indicated by the integer. In this way entries can be commonly formatted even when they are not contiguous. The integers are assigned sequentially as the format specification is parsed; users will likely need trial and error to find the right value in a complicated table with multiple formats.

Example:  Format two separated columns with the same format.
\begin{center}
<<results=tex>>=
latex( tabular( (F+1) ~ X*(Format(digits=2)*mean 
                    + (n=1) + .Format(1)*sd) ) )
@
\end{center}

\subsubsection{\code{Heading() }}

Normally \code{tabular()} generates row and column labels by deparsing the expression
being tabulated.  These can be changed by using the \code{Heading()} pseudo-function, which
replaces the heading on the next object found.  The heading can either be the name of a 
function or a string in quotes, which will be displayed as entered (so \LaTeX\ codes can be used).

If no argument is passed, the next label is suppressed.

Example:  Replace \code{F} with a Greek $\Phi$, and suppress the label for \code{X}.
\begin{center}
<<results=tex>>=
latex( tabular( (Heading("$\\Phi$")*F+1) ~ (n=1) 
           + Format(digits=2)*Heading()*X*(mean + sd) ) )
@
\end{center}

\subsubsection{\code{Justify()}}  

The \code{Justify()} pseudo-function is used to specify the text justification of the headers and data values in the table.
If called with one argument, that value is used for both labels and data; if called with two arguments, the first is used for the 
labels, the second for the data.  If no \code{Justify()} specification is given, the default passed to \code{format()}, \code{print()} or \code{latex()} will
be used.

Example: 
\begin{center}
<<results=tex>>=
latex( tabular( Justify(r)*(F+1) ~ Justify(c)*(n=1) 
   + Justify(c,r)*Format(digits=2)*X*(mean + sd) ) )
@
\end{center}

\subsection{Formula Functions}
\label{sec:tableformulas}

Currently several examples of formula functions are provided.   Not all are
particularly robust; e.g. \code{Hline()} only works for \LaTeX\ output and must be in a
particular position in the formula.  Users can provide their own as well.  
Such functions
should return a language object, which will be substituted into the formula in place of the Formula
function call.

\subsubsection{\code{All()}}

This function expands all the columns from a dataframe into separate variables in the table.
It has syntax

\begin{Schunk}
\begin{Sinput}
All(df, numeric=TRUE, character=FALSE, logical=FALSE, 
        factor=FALSE, complex=FALSE, raw=FALSE, other=FALSE,
        texify=TRUE)
\end{Sinput}
\end{Schunk}

The arguments are
\begin{description}
\item[\code{df}] A dataframe or matrix whose columns are to be displayed
\item[\code{numeric}, \code{character}, \code{logical}, \code{factor}, \code{complex}
and \code{raw}] Whether to include columns of the corresponding types in the table.
\item[\code{other}] Whether to include columns that match none of the previous types.
\item[\code{texify}] Whether to escape \LaTeX\ special characters.  See section \ref{sec:formatdetails}.
\end{description}

If functions are given for any of the selection arguments, the columns will be
transformed according to the specified function before inclusion.  For example,
using \code{factor=as.character} will convert factors into character vectors in the table.

Example:  Show the means of the numeric columns in the iris data.

\begin{center}
<<results=tex>>=
latex( tabular( Species ~ Heading()*mean*All(iris), data=iris) )
@
\end{center}

\subsubsection{\code{Hline()}}

This function produces horizontal lines in the table.  It only works for LaTeX output, and
must be the first factor in a term in the table formula.
It has syntax

\begin{Schunk}
\begin{Sinput}
Hline(columns)
\end{Sinput}
\end{Schunk}

The argument is
\begin{description}
\item[\code{columns}] An optional vector listing which columns should 
get the line.  
\end{description}

Example:  

\begin{center}
<<results = tex>>=
latex( tabular( Species + Hline(2:5) + 1 
                         ~ Heading()*mean*All(iris), data=iris) )
@
\end{center}

\subsubsection{\code{Literal()}}
\label{sec:Literal}

This function inserts literal text as a label.  It has syntax

\begin{Schunk}
\begin{Sinput}
Literal(x)
\end{Sinput}
\end{Schunk}

The single argument is the text to insert.  It is used by the \code{Hline()} function to insert the text.

\subsubsection{\code{PlusMinus()}}

This function produces table entries like $x \pm y$ with an optional header.
It has syntax

\begin{Schunk}
\begin{Sinput}
PlusMinus(x, y, head, xhead, yhead, digits=2, ...)
\end{Sinput}
\end{Schunk}

The arguments are
\begin{description}
\item[\code{x, y}] These are expressions which should each generate a single column in the table.  The \code{x}
value will be flush right, the \code{y} value will be flush left, with the $\pm$ symbol between. 
\item[\code{head}] If not missing, this header will be put over the pair of columns.
\item[\code{xhead, yhead}] If not missing, these will be put over the individual columns.
\item[\code{digits, ...}] These arguments will be passed to the standard \code{format()} function.
\end{description}

Example:  Display mean $\pm$ standard error.
\begin{center}
<<results=tex>>=
stderr <- function(x) sd(x)/sqrt(length(x))
latex( tabular( (Species+1) ~ All(iris)*
          PlusMinus(mean, stderr, digits=1), data=iris ) )
@
\end{center}

\subsubsection{\code{Factor()}, \code{RowFactor()} and \code{Multicolumn()}}
\label{sec:RowFactor}

The \code{Factor()} function converts its argument into a factor, but keeps the
original name for a column heading.  \code{RowFactor()} is designed to be used only
for \LaTeX\ output:  it produces multiple rows the way a factor does, but 
with more flexibility in the formatting.  The \code{Multicolumn()} function is also designed
for \LaTeX\ output:  it displays factor levels in the style where the level is displayed across 
multiple columns on its own line.

They have syntax

\begin{Schunk}
\begin{Sinput}
Factor(x, name, levelnames, texify=TRUE)
RowFactor(x, name, levelnames, spacing=3, space=1, 
                    nopagebreak="\\nopagebreak", texify=TRUE)
Multicolumn(x, name, levelnames, width=2, first=1, justify="l",
                    texify=TRUE)
\end{Sinput}
\end{Schunk}

The arguments are
\begin{description}
\item[x] A variable to be treated as a factor.
\item[name] The name to be used for the factor; by default, the name passed as \code{x}.
\item[levelnames] An optional argument to allow customization of the displayed level names.
\item[texify] Whether to escape \LaTeX\ special characters.  See section \ref{sec:formatdetails}.
\item[spacing] Extra spacing is added before every group of \code{spacing} lines.
\item[space] How much extra space to add (in ``ex'' units).
\item[nopagebreak] Macro to insert to suppress page breaks except between groups.
\item[width] How many columns for the label?
\item[first] What is the first column?
\item[justify] What justification to use.
\end{description}

Example:  Show the first 15 lines of the iris dataset, in groups of 5 lines.

<<results=tex>>=
subset <- 1:15
latex( tabular( RowFactor(subset, "$i$", spacing=5)  ~ 
       All(iris[subset,], factor=as.character)*Heading()*identity ) )
@
\\

For longer tables, 
the \code{"longtable"} environment allows the table to cross page boundaries.  Using
this is more complicated, as in the example below.
The \code{toprule}
setting inserts the caption as well as the top rule, because the \pkg{longtable} package 
requires it to be \textit{within}
the table.  The
\code{midrule} setting gets the headings to repeat on subsequent 
pages.\footnote{I've done all of this
in a way that is compatible with the \pkg{booktabs} style; if you want the
default style, use \texttt{\textbackslash hline} in place of the \pkg{booktabs}
\texttt{\textbackslash toprule} 
and \texttt{\textbackslash midrule} macros in the
\code{options} settings instead.}
To avoid extra spacing at the top of those pages, we need
to undo the automatic addition of a \verb!\normalbaselineskip! there, and use
\code{suppressfirst=FALSE} so that the first page doesn't get messed up.  Whew!

<<results=tex>>=
subset <- 1:50
latex( tabular( RowFactor(subset, "$i$", spacing=5, 
                                             suppressfirst=FALSE)  ~ 
       All(iris[subset,], factor=as.character)*Heading()*identity ),
       options = list(tabular="longtable",
          toprule="\\caption{This table crosses page boundaries.}\\\\
              \\toprule",
midrule="\\midrule\\\\[-2\\normalbaselineskip]\\endhead\\hline\\endfoot") )
@

To suppress the row numbering, use  \code{suppress=3} in the call to
tabular.  (It is 3 because we need to suppress the column heading, the
rewritten labels for the rows, and the original labels.  Trial and error is
the best way to determine this!)  Unfortunately, the spacing features
of \code{RowFactor()} won't work without the row labels.
\begin{center}
<<results=tex>>=
subset <- 1:10
latex( tabular( Factor(subset)  ~ 
       All(iris[subset,], factor=as.character)*Heading()*identity, 
       suppress=3 ) )
@
\end{center}

To get group labels to span multiple columns, the \code{levelnames} argument
can be used with embedded \LaTeX\ code.  For example,
\begin{center}
<<results=tex>>=
latex( tabular( Multicolumn(Species, width=3, 
            levelnames=paste("\\textit{Iris", levels(Species),"}")) 
            * (mean + sd)  ~ All(iris), data=iris, suppress=1))
@
\end{center}

\section{Further Details}

\subsection{Formatting}
\label{sec:formatdetails}

As mentioned in \ref{sec:formats}, formatting in \pkg{tables} depends on the standard \code{format()}
function or other user-selected functions.  Here are the details of how it is done.

The \code{format.tabular()} method does the first part of the work.  It constructs the calls
to the appropriate formatting functions and uses them to format all of the entries in the table.
This converts the \code{tabular} object to a character array.

The procedure goes as follows:
\begin{enumerate}
\item Entries in the table without specified formatting are formatted first, separately
by column using the \code{format()} function.  This is so that entries in a given column will end up
with the same character width and (with the default settings) with the same number of decimal places.

\item Entries in the table with specified formatting are grouped according to the format specification.
For example, if two columns both share the same \code{Format()}, they will be formatted in
a single call.  This results in such entries ending up
with the same character width and (with the default settings) with the same number of decimal places.

\item If the \code{latex} argument is \code{TRUE},
any numeric entries are passed to the \code{latexNumeric()} function (see \ref{sec:latexNumeric}), which replaces blanks and
minus signs with fixed width spaces and \LaTeX\ minus signs 
so that all entries will display in the same width.  This means that numeric values will
normally have decimal points aligned, unless the formatting function explicitly removes
leading spaces.    Non-numeric entries are passed through the \code{Hmisc::latexTranslate} function
so that special characters are displayed properly.

\item If the \code{latex} argument is \code{FALSE}, 
an attempt is made to justify the results using simple ASCII spacing, according to the \code{Justify()}
specification with the \code{justification} argument used as a default.
\end{enumerate}

Note that \LaTeX\ special characters will be escaped in data when \code{latex()} is called, but
row and column headings generated by \code{All()}, \code{Factor()}, etc. will by default have the escapes
done in all cases.  Those functions have a \code{texify} argument that can be set to \code{FALSE}
to disable this behaviour (e.g. if the label is meant to be processed by \LaTeX).  For example,
with the definition
<<>>=
df <- data.frame(A = factor(c( "$", "\\" ) ), B_label=1:2)
@
the code
<<eval=FALSE>>=
latex( tabular( mean ~ A*B_label, data=df ) ) 
@
wouild fail, as the labels would include the special characters.  But this will work:
\begin{center}
<<results=tex>>=
latex( tabular( mean ~ Factor(A)*All(df), data=df ) ) 
@
\end{center}

\subsection{Missing Values}

By default, most summary statistics in R return \code{NA} if any of the input values are 
\code{NA}, but have ways to treat \code{NA} differently.  For example, the \code{mean()}
function has the \code{na.rm} argument:
<<>>=
dat <- data.frame( a = c(1, 2, 3, NA), b = 1:4 )
mean(dat$a)
mean(dat$a, na.rm=TRUE)
@

The \code{tabular()} function itself has no way to specify special \code{NA} handling, but
there are several ways to do this yourself, depending on how you want them handled.
To ignore \code{NA} values within the column, define a new function which sets the
different behaviour.  For example, 
\begin{center}
<<results=tex>>=
Mean <- function(x) base::mean(x, na.rm=TRUE)
latex( tabular( Mean ~ a + b, data=dat ) )
@
\end{center}
An alternative approach is to use \code{na.omit()} to work on a subset of your data which has 
rows with any missing values removed, e.g. 
\begin{center}
<<results=tex>>=
latex( tabular( mean ~ a + b, data = na.omit(dat) ) )
@
\end{center}
A third possibility is to use the \code{complete.cases()} function to remove missings
only from some columns, e.g.
\begin{center}
<<results=tex>>=
latex( tabular( 
  Mean ~ (1 + Heading(Complete)*complete.cases(dat)) * (a + b), 
               data=dat ) )
@
\end{center}

\section*{Acknowledgments}

I gratefully acknowledge helpful suggestions and hints from Rich Heiberger, Frank Harrell and Dieter Menne.

\bibliography{tables}

\end{document}
